# Cloud/SCDF Deployment Configuration
# This profile supports both Spring Cloud Data Flow (SCDF) and cloud deployments
app.processor.mode=scdf

# OpenAI Configuration (from VCAP_SERVICES)
# Will use the first service that provides an API key
# You can bind any service that provides 'api-key' in its credentials
spring.ai.openai.api-key=${vcap.services.*.credentials.api-key}
spring.ai.openai.embedding.options.model=${vcap.services.*.credentials.embedding-model:text-embedding-3-small}

# PostgreSQL Configuration (auto-configured by Spring Boot's Cloud Foundry support)
# Will automatically bind to any PostgreSQL service in VCAP_SERVICES
spring.datasource.driver-class-name=org.postgresql.Driver

# Database Connection Pooling for Performance
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# Let Spring Boot auto-configure the DataSource from VCAP_SERVICES
# It will automatically detect and use the first bound database service
# and set the following properties:
# - spring.datasource.url
# - spring.datasource.username
# - spring.datasource.password

# Vector Store Configuration (pgvector)
spring.ai.vectorstore.pgvector.enabled=true
spring.ai.vectorstore.pgvector.initialize-schema=true
spring.ai.vectorstore.pgvector.dimensions=768  
spring.ai.vectorstore.pgvector.distance-type=COSINE_DISTANCE
#spring.ai.vectorstore.pgvector.table-name=embeddings

# Cloud Foundry specific settings
spring.application.name=${vcap.application.name:embedProc}
info.app.name=@project.artifactId@
info.app.version=@project.version@

# Enable Cloud Foundry connector
#spring.cloud.cloudfoundry.enabled=true

# Monitoring & Metrics Configuration
# Enable RabbitMQ metrics publishing for distributed monitoring
app.monitoring.rabbitmq.enabled=true
app.monitoring.rabbitmq.queue-name=embedproc.metrics

# Logging configuration - Reduced verbosity to prevent log rate limits
logging.level.root=INFO
logging.level.com.baskettecase=INFO
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# Application-specific logging - Reduced to INFO level
logging.level.com.baskettecase.embedProc=INFO
logging.level.org.springframework.ai=WARN
logging.level.org.springframework.cloud.stream=WARN

# Performance Monitoring
management.metrics.export.prometheus.enabled=true
management.endpoint.metrics.enabled=true
management.endpoint.prometheus.enabled=true

# Spring Cloud Stream Configuration
# These will be set by cloud deployment or SCDF
#app.processor.cloud.input-channel=textProcInput
#app.processor.cloud.output-channel=textProcOutput

# Actuator and probe endpoints
management.endpoints.web.exposure.include=health,info
management.endpoint.health.probes.enabled=true
management.server.port=8081
#debug=true

# Spring Cloud Stream bindings
spring.cloud.stream.bindings.embedProc-in-0.destination=textInput
spring.cloud.stream.bindings.embeddingLogOutput.destination=embedding.log

# Spring Cloud Function Configuration
spring.cloud.function.scan.packages=com.baskettecase.embedProc.processor
spring.cloud.function.definition=embedProc

# Async Processing Configuration for Performance
spring.task.execution.pool.core-size=4
spring.task.execution.pool.max-size=8
spring.task.execution.pool.queue-capacity=100
spring.task.execution.thread-name-prefix=embedProc-

# Default query text for vector operations
app.query.text="What products does UDM contain?"

# Enhanced Chunking Configuration
# Smaller chunks (200-500 words) for more precise matches with overlap
app.chunking.max-words-per-chunk=500
app.chunking.overlap-words=50